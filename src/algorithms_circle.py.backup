from dataclasses import dataclass

import logging
import math, time
from typing import Any, Generator, Generic, TypeVar, overload
import numpy as np
import cv2
from numpy._typing._array_like import NDArray

from utils import Circle, Hough, PositionArray, Vector, VectorArray
from skimage.measure import CircleModel, ransac

# ============== 预处理 & 质量评估 ==============


def adaptive_preprocessing(image: np.ndarray, brightness_mode="auto"):
    """将图像转换为适合圆检测的灰度，并做适度增强。返回 (processed_gray, brightness_mode)"""
    if image.ndim > 2:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image.copy()
    if gray.dtype != np.uint8:
        cv2.normalize(
            gray.astype(np.float32), gray, 0, 255, cv2.NORM_MINMAX, dtype=cv2.CV_8U
        )

    mean_brightness = float(np.mean(gray))
    if brightness_mode == "auto":
        if mean_brightness > 140:
            brightness_mode = "bright"
        elif mean_brightness < 70:
            brightness_mode = "dark"
        else:
            brightness_mode = "normal"

    if brightness_mode == "bright":
        filtered = cv2.bilateralFilter(gray, 9, 75, 75)
    elif brightness_mode == "dark":
        clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(8, 8))
        enhanced = clahe.apply(gray)
        filtered = cv2.bilateralFilter(enhanced, 9, 75, 75)
    else:
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
        enhanced = clahe.apply(gray)
        filtered = cv2.bilateralFilter(enhanced, 9, 75, 75)

    return filtered, brightness_mode


def evaluate_circle_quality(image_gray, circle):
    """对检测到的圆做一个稳定的质量打分，越大越好（0~100）。"""
    try:
        cx, cy, radius = int(circle[0]), int(circle[1]), int(circle[2])
        h, w = image_gray.shape[:2]

        angles = np.linspace(0, 2 * np.pi, 48)
        edge_strengths = []
        for angle in angles:
            ix = int(cx + (radius - 2) * np.cos(angle))
            iy = int(cy + (radius - 2) * np.sin(angle))
            ox = int(cx + (radius + 2) * np.cos(angle))
            oy = int(cy + (radius + 2) * np.sin(angle))
            if 0 <= ix < w and 0 <= iy < h and 0 <= ox < w and 0 <= oy < h:
                inner_val = float(image_gray[iy, ix])
                outer_val = float(image_gray[oy, ox])
                edge_strengths.append(abs(outer_val - inner_val))

        if not edge_strengths:
            return 0.0

        avg_edge = float(np.mean(edge_strengths))
        consistency = 1.0 / (1.0 + np.std(edge_strengths) / max(1.0, avg_edge))
        score = avg_edge * consistency
        return float(min(100.0, score))
    except Exception:
        return 0.0


# ============== 高光裁剪和星点抑制辅助 ==============
def _clip_highlights(gray, pct=99.8):
    """Clip very bright highlights (glare/bloom) to a percentile to help Hough/RANSAC."""
    g = gray.astype(np.float32)
    cap = np.percentile(g, pct)
    if cap <= 0:
        return gray
    g = np.minimum(g, cap)
    g = g / (cap + 1e-6) * 255.0
    return g.astype(np.uint8)


def _remove_stars_small(gray):
    """Suppress point-like stars/noise while preserving lunar rim."""
    # Top-hat to remove small bright dots
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    tophat = cv2.morphologyEx(gray, cv2.MORPH_TOPHAT, kernel)
    g = cv2.subtract(gray, tophat)
    # Gentle median to clean salt-pepper
    g = cv2.medianBlur(g, 3)
    return g


# ============== 稳健外缘 RANSAC（用于血月/缺口） ==============


def _fit_circle_ransac(
    points: PositionArray, iterations=120, threshold=2.0, min_inliers=40
) -> None | Circle:
    if len(points) < 3:
        return None
    try:
        model, inliers = ransac(
            data=points._arr,
            model_class=CircleModel,
            min_samples=3,
            residual_threshold=threshold,
            max_trials=iterations,
            stop_probability=0.99,  # type: ignore
        )
        if np.sum(inliers) < min_inliers:  # type: ignore
            return None
        cy, cx, r = model.params  # type: ignore
        return Circle(float(cx), float(cy), float(r))
    except Exception:
        return None


def _edge_points_outer_rim(
    gray: np.ndarray, prev_circle: Circle | None = None
) -> PositionArray | None:
    edges = cv2.Canny(gray, 50, 150)
    ys, xs = np.nonzero(edges)
    if len(xs) == 0:
        return None

    pts = PositionArray(np.stack([xs, ys], axis=1), safe=False)
    if prev_circle is None:
        return pts
    vectors = pts - prev_circle
    distance_cond = (
        prev_circle.radius * 0.85 < vectors.norms() < prev_circle.radius * 1.15
    )

    valid_pts = pts.filter(distance_cond)
    valid_vectors = vectors.filter(distance_cond)
    valid_x = valid_vectors.x.astype(np.int32)
    valid_y = valid_vectors.y.astype(np.int32)

    gx = cv2.Sobel(gray, cv2.CV_32F, 1, 0, ksize=3)
    gy = cv2.Sobel(gray, cv2.CV_32F, 0, 1, ksize=3)

    valid_gx = gx[valid_y, valid_x]
    valid_gy = gy[valid_y, valid_x]
    gradients = VectorArray(np.stack([valid_gx, valid_gy], axis=1), safe=False)

    cond = gradients.normalize() * valid_vectors.normalize() > 0.2
    keep = valid_pts.filter(cond)
    if len(keep) < 30:
        return None
    return keep


def detect_circle_robust(
    gray: np.ndarray, prev_circle: Circle | None = None
) -> Circle | None:
    pts = _edge_points_outer_rim(gray, prev_circle)
    if not pts:
        return prev_circle
    cand = _fit_circle_ransac(pts)
    if cand is None:
        return prev_circle
    vectors = pts - cand
    arctans = np.arctan2(vectors.y, vectors.x)
    span: np.float64 = np.ptp(arctans)
    if prev_circle and span < (2 * np.pi / 3.0):  # <120°
        cand = Circle(cand.x, cand.y, prev_circle.radius)
    return cand


# ============== 遮罩相位相关（亚像素平移微调） ==============


def masked_phase_corr(ref_gray: NDArray, tgt_gray: NDArray, circle: Circle) -> Vector:
    H, W = ref_gray.shape
    Y, X = np.ogrid[:H, :W]
    dist = np.sqrt((X - circle.x) ** 2 + (Y - circle.y) ** 2)

    mask = (dist <= circle.radius * 0.98).astype(np.float32)
    band = (dist >= circle.radius * 0.90) & (dist <= circle.radius * 0.98)
    t = (dist[band] - circle.radius * 0.90) / (circle.radius * 0.08 + 1e-6)
    mask[band] = 0.5 * (1 + np.cos(np.pi * (1 - t)))

    rg = (ref_gray * mask).astype(np.float32)
    tg = (tgt_gray * mask).astype(np.float32)

    (dx, dy), _ = cv2.phaseCorrelate(rg, tg)
    return Vector(dx, dy)


# ============== 辅助：粗估 & 环形 ROI（抑制星点/加速霍夫） ==============


def _rough_center_radius(gray: np.ndarray, min_r: float, max_r: float) -> Circle | None:
    g = cv2.GaussianBlur(gray, (0, 0), 2.0)
    # Use adaptive + Otsu fallback to handle glare/crescent
    thr = max(10, int(np.mean(g) + 0.3 * np.std(g)))
    _, bw1 = cv2.threshold(g, thr, 255, cv2.THRESH_BINARY)
    _, bw2 = cv2.threshold(g, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    bw_adap = cv2.adaptiveThreshold(
        g.astype(np.uint8), 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 51, -5
    )
    bw = cv2.max(bw1, cv2.max(bw2, bw_adap))
    bw = cv2.morphologyEx(
        src=bw,
        op=cv2.MORPH_OPEN,
        kernel=cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5)),
        iterations=1,
    )
    cnts, _ = cv2.findContours(bw, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not cnts:
        return None
    c = max(cnts, key=cv2.contourArea)
    (cx, cy), r = cv2.minEnclosingCircle(c)
    if r < min_r * 0.6 or r > max_r * 1.6:
        return None
    return Circle(cx, cy, r)


def _ring_mask(h, w, circle: Circle, inner=0.70, outer=1.15) -> NDArray[np.uint8]:
    Y, X = np.ogrid[:h, :w]
    dist = np.sqrt((X - circle.x) ** 2 + (Y - circle.y) ** 2)
    m = ((dist >= circle.radius * inner) & (dist <= circle.radius * outer)).astype(
        np.uint8
    ) * 255
    return m


# ============== UI 调参可视化：分析区域掩膜（仅供显示） ==============
def build_analysis_mask(
    img_gray: NDArray,
    brightness_min=3 / 255.0,
    min_radius: float | None = None,
    max_radius: float | None = None,
):
    """
    仅供 UI 调参窗口显示“分析区域”用：
    - uint8 归一化 -> 轻度去噪
    - Otsu 阈值 与 亮度下限并联
    - 形态学开运算清点
    - 仅保留最大连通域
    返回 bool(H,W)。不影响主流程检测。
    """
    try:
        g = img_gray.copy()
        if g.dtype != np.uint8:
            cv2.normalize(
                g.astype(np.float32), g, 0, 255, cv2.NORM_MINMAX, dtype=cv2.CV_8U
            )
        g = cv2.GaussianBlur(g, (3, 3), 0)
        _, otsu = cv2.threshold(g, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
        floor_t = max(1, int(round(float(brightness_min) * 255.0)))
        _, floor = cv2.threshold(g, floor_t, 255, cv2.THRESH_BINARY)
        m = cv2.bitwise_and(otsu, floor)
        k = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
        m = cv2.morphologyEx(m, cv2.MORPH_OPEN, k, iterations=1)
        cnts, _ = cv2.findContours(m, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        if not cnts:
            return np.zeros_like(m, dtype=bool)
        c = max(cnts, key=cv2.contourArea)
        keep = np.zeros_like(m)
        cv2.drawContours(keep, [c], -1, 255, thickness=cv2.FILLED)
        return keep.astype(bool)
    except Exception:
        # 兜底：整图 False
        shape = (1, 1) if img_gray is None else img_gray.shape[:2]
        return np.zeros(shape, dtype=bool)


# 兼容 UI 中的优先调用名
build_analysis_mask_ui = build_analysis_mask

# ============== 主检测（供 pipeline 调用） ==============


def _touches_border(circle: Circle, size: Vector[int], margin: int = 5) -> bool:
    if circle is None:
        return True

    return (
        (circle.x - circle.radius < margin)
        or (circle.y - circle.radius < margin)
        or (circle.x + circle.radius > size.x - margin)
        or (circle.y + circle.radius > size.y - margin)
    )


def detect_circle_phd2_enhanced(
    image: NDArray,
    hough: Hough,
    strong_denoise=False,
    prev_circle: Circle | None = None,
) -> tuple[Circle, NDArray, float]:

    t0 = time.time()
    TIME_BUDGET = 6.0  # seconds per frame guard for extreme cases
    processed, brightness_mode = adaptive_preprocessing(image, "auto")
    # 可选：强力降噪（仅影响检测，不影响最终成片）
    if strong_denoise:
        try:
            # fast NLM 能在强噪场景下保持边缘
            processed = cv2.fastNlMeansDenoising(
                processed, None, h=10, templateWindowSize=7, searchWindowSize=21
            )
            # 轻度中值进一步压盐胡椒
            processed = cv2.medianBlur(processed, 3)
        except Exception:
            pass
    best_circle: Circle | None = None
    best_score: float = 0

    # Use a detection-optimized copy to make Hough/RANSAC more stable on glare/bloom frames
    processed_det = _remove_stars_small(_clip_highlights(processed, pct=99.8))
    H, W = processed_det.shape
    proc_for_hough = processed_det

    # —— 粗估中心半径，构建环形 ROI —— #
    est: Circle | None = _rough_center_radius(
        processed_det, hough.minRadius, hough.maxRadius
    )
    if est is not None:
        ring = _ring_mask(H, W, est, inner=0.70, outer=1.15)
        proc_for_hough = cv2.bitwise_and(processed_det, processed_det, mask=ring)
    # —— 若给出上一帧圆心半径，合并一个“历史先验”环形 ROI —— #
    if prev_circle:
        try:

            inner = max(
                0.70,
                min(0.85, (hough.minRadius / max(prev_circle.radius, 1e-6)) * 0.9),
            )
            outer = min(
                1.30,
                max(1.15, (hough.maxRadius / max(prev_circle.radius, 1e-6)) * 1.05),
            )
            ring_prev = _ring_mask(H, W, prev_circle, inner=inner, outer=outer)
            proc_for_hough = cv2.bitwise_and(
                proc_for_hough, proc_for_hough, mask=ring_prev
            )
        except Exception:
            pass
    else:
        max_side = max(H, W)
        if max_side > 1800:
            scale = 1800.0 / max_side
            small = cv2.resize(
                processed_det,
                (int(W * scale), int(H * scale)),
                interpolation=cv2.INTER_AREA,
            )
            new_hough = Hough(
                minRadius=max(1, int(hough.minRadius * scale)),
                maxRadius=max(2, int(hough.maxRadius * scale)),
                param1=hough.param1,
                param2=max(hough.param2 - 5, 10),
            )

            try:
                sc = cv2.HoughCircles(
                    small,
                    cv2.HOUGH_GRADIENT,
                    dp=1.2,
                    minDist=small.shape[0] // 2,
                    **new_hough._asdict(),
                )
                if sc is not None:
                    circle = sc[0][0]
                    circle = Circle(
                        circle[0] / scale, circle[1] / scale, circle[2] / scale
                    )
                    quality = evaluate_circle_quality(processed, circle) * 1.02
                    if quality > best_score:
                        best_score, best_circle = quality, circle
                        logging.info("缩放霍夫(thumb)")
            except Exception:
                pass

    # —— 稳健外缘 RANSAC —— #
    if time.time() - t0 > TIME_BUDGET:
        # Fall back to quick thumbnail Hough on the detection image
        scale = min(1.0, 1600.0 / max(H, W))
        small = cv2.resize(
            processed_det,
            (int(W * scale), int(H * scale)),
            interpolation=cv2.INTER_AREA,
        )
        new_hough = Hough(
            minRadius=max(1, int(hough.minRadius * scale)),
            maxRadius=max(2, int(hough.maxRadius * scale)),
            param1=max(hough.param1, 20),
            param2=max(hough.param2 - 5, 8),
        )
        sc = cv2.HoughCircles(
            small,
            cv2.HOUGH_GRADIENT,
            dp=1.2,
            minDist=small.shape[0] // 2,
            **new_hough._asdict(),
        )
        if sc is not None:
            circle = sc[0][0]
            best_circle = Circle(
                circle[0] / scale, circle[1] / scale, circle[2] / scale
            )
            best_score = evaluate_circle_quality(processed, best_circle) * 0.9
            logging.info("超时降级(thumb)")
            return best_circle, processed, best_score
    try:
        robust = detect_circle_robust(processed_det, None)
        if robust is not None:
            quality = evaluate_circle_quality(processed, robust) * 1.05
            if quality > best_score:
                best_score = quality
                best_circle = robust
                logging.info("稳健外缘RANSAC")
    except Exception:
        pass

    # —— 标准霍夫（在 ROI 上） —— #
    if time.time() - t0 > TIME_BUDGET:
        scale = min(1.0, 1600.0 / max(H, W))
        small = cv2.resize(
            processed_det,
            (int(W * scale), int(H * scale)),
            interpolation=cv2.INTER_AREA,
        )
        standard_hough = Hough(
            minRadius=max(1, int(hough.minRadius * scale)),
            maxRadius=max(2, int(hough.maxRadius * scale)),
            param1=max(hough.param1, 20),
            param2=max(hough.param2 - 5, 8),
        )
        sc = cv2.HoughCircles(
            small,
            cv2.HOUGH_GRADIENT,
            dp=1.2,
            minDist=small.shape[0] // 2,
            **standard_hough._asdict(),
        )
        if sc is not None:
            circle = sc[0][0]
            best_circle = Circle(
                circle[0] / scale, circle[1] / scale, circle[2] / scale
            )
            best_score = evaluate_circle_quality(processed, best_circle) * 0.9
            logging.info("超时降级(thumb)")
            return best_circle, processed, best_score
    height, _ = processed_det.shape
    try:

        circles = cv2.HoughCircles(
            proc_for_hough,
            cv2.HOUGH_GRADIENT,
            dp=1,
            minDist=height,
            **hough._asdict(),
        )
        if circles is not None:
            for circle in circles[0]:
                quality = evaluate_circle_quality(processed, circle)
                if quality > best_score:
                    best_score, best_circle = quality, circle
                    detection_method = f"标准霍夫(P1={hough.param1},P2={hough.param2})"
    except Exception:
        pass

    # —— 自适应参数霍夫（在 ROI 上） —— #
    if best_score < 15:
        try:
            if brightness_mode == "bright":
                new_hough = Hough(
                    minRadius=hough.minRadius,
                    maxRadius=hough.maxRadius,
                    param1=hough.param1 + 20,
                    param2=max(hough.param2 - 5, 10),
                )

            elif brightness_mode == "dark":
                new_hough = Hough(
                    minRadius=hough.minRadius,
                    maxRadius=hough.maxRadius,
                    param1=max(hough.param1 - 15, 20),
                    param2=max(hough.param2 - 10, 5),
                )
            else:
                new_hough = Hough(
                    minRadius=hough.minRadius,
                    maxRadius=hough.maxRadius,
                    param1=hough.param1,
                    param2=max(hough.param2 - 8, 8),
                )

            circles2 = cv2.HoughCircles(
                proc_for_hough,
                cv2.HOUGH_GRADIENT,
                dp=1.2,
                minDist=height // 2,
                **new_hough._asdict(),
            )
            if circles2 is not None:
                for circle in circles2[0]:
                    quality = evaluate_circle_quality(processed, circle)
                    if quality > best_score:
                        best_score, best_circle = quality, circle
                        logging.info(
                            f"自适应霍夫(P1={new_hough.param1},P2={new_hough.param2})"
                        )

        except Exception:
            pass

    # —— 轮廓备选 —— #
    if best_score < 10:
        try:
            mean_val = float(np.mean(processed_det))
            tv = max(50, int(mean_val * 0.7))
            _, binary = cv2.threshold(processed_det, tv, 255, cv2.THRESH_BINARY)
            kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
            binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)
            contours, _ = cv2.findContours(
                binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
            )
            for cnt in contours:
                area = cv2.contourArea(cnt)
                if (
                    hough.minRadius**2 * np.pi * 0.3
                    <= area
                    <= hough.maxRadius**2 * np.pi * 2.0
                ):
                    (cx, cy), r = cv2.minEnclosingCircle(cnt)
                    if hough.minRadius <= r <= hough.maxRadius:
                        circle = Circle(cx, cy, r)
                        quality = evaluate_circle_quality(processed, circle) * 0.7
                        if quality > best_score:
                            best_score, best_circle = quality, circle
                            detection_method = f"轮廓检测(T={tv})"
        except Exception:
            pass

    # —— padding-based fallback —— #
    if time.time() - t0 > TIME_BUDGET:
        scale = min(1.0, 1600.0 / max(H, W))
        small = cv2.resize(
            processed_det,
            (int(W * scale), int(H * scale)),
            interpolation=cv2.INTER_AREA,
        )
        new_hough = Hough(
            minRadius=max(1, int(hough.minRadius * scale)),
            maxRadius=max(2, int(hough.maxRadius * scale)),
            param1=max(hough.param1, 20),
            param2=max(hough.param2 - 5, 8),
        )
        sc = cv2.HoughCircles(
            small,
            cv2.HOUGH_GRADIENT,
            dp=1.2,
            minDist=small.shape[0] // 2,
            **new_hough._asdict(),
        )
        if sc is not None:
            circle = sc[0][0]
            best_circle = Circle(
                circle[0] / scale, circle[1] / scale, circle[2] / scale
            )
            best_score = evaluate_circle_quality(processed, best_circle) * 0.9
            logging.info("超时降级(thumb)")
            return best_circle, processed, best_score

    need_pad: bool = (
        (best_circle is None) or (best_score < 10) or _touches_border(best_circle, W, H)
    )
    if need_pad:
        pad = int(max(32, round(hough.maxRadius * 1.2)))
        processed_pad = cv2.copyMakeBorder(
            processed_det,
            pad,
            pad,
            pad,
            pad,
            borderType=cv2.BORDER_CONSTANT,
            value=0,
        )
        # Use constant black padding to avoid mirrored ghosts influencing Hough
        est_p = _rough_center_radius(
            processed_pad, int(hough.minRadius * 1.1), int(hough.maxRadius * 1.1)
        )
        if est_p is not None:
            ring_p = _ring_mask(
                processed_pad.shape[0],
                processed_pad.shape[1],
                est_p,
                inner=0.70,
                outer=1.15,
            )
            proc_pad_for_hough = cv2.bitwise_and(
                processed_pad, processed_pad, mask=ring_p
            )
        else:
            proc_pad_for_hough = processed_pad
        new_hough = Hough(
            minRadius=int(max(1, hough.minRadius * 1.1)),
            maxRadius=int(max(2, hough.maxRadius * 1.1)),
            param1=max(hough.param1, 20),
            param2=max(hough.param2 - 5, 8),
        )
        circles_p = cv2.HoughCircles(
            proc_pad_for_hough,
            cv2.HOUGH_GRADIENT,
            dp=1.2,
            minDist=processed_pad.shape[0] // 2,
            **new_hough._asdict(),
        )

        if not circles_p:
            robust_p = detect_circle_robust(processed_pad, None)
            if robust_p:
                circles = [robust_p]
            else:
                circles = []
        else:
            circles = [Circle(*c) for c in circles_p[0]]
        for cp in circles:
            # Build a matching padded version of the original processed (for scoring)
            scored_pad = processed_pad  # using detection pad for speed; acceptable because only ranking
            q_pad = evaluate_circle_quality(scored_pad, cp)

            hh, ww = processed_pad.shape[:2]
            yy, xx = np.ogrid[:hh, :ww]
            mask = (xx - cp.x) ** 2 + (yy - cp.y) ** 2 <= cp.radius**2
            # 对应原图区域
            crop = mask[pad : pad + H, pad : pad + W]
            visible_ratio = float(np.count_nonzero(crop)) / (
                np.pi * cp.radius**2 + 1e-6
            )
            q_adj = max(
                10.0, float(q_pad) * np.sqrt(max(0.05, min(1.0, visible_ratio)))
            )
            if q_adj > best_score:
                # 映射回原图坐标
                best_circle = Circle(cp.x - pad, cp.y - pad, cp.radius)
                best_score = q_adj

    # —— 最终半径窗口一致性检查（严格遵守 UI 设定） —— #

    if best_circle and not (hough.minRadius <= best_circle.radius <= hough.maxRadius):
        # 在严格窗口内再做一次快速霍夫重试
        height, width = processed_det.shape
        _minDist_coreS = max(16, min(height, width) // 4)
        new_hough = Hough(
            minRadius=max(1, hough.minRadius),
            maxRadius=hough.maxRadius,
            param1=max(hough.param1, 20),
            param2=max(hough.param2 - 5, 8),
        )
        scS = cv2.HoughCircles(
            processed_det,
            cv2.HOUGH_GRADIENT,
            dp=1.2,
            minDist=_minDist_coreS,
            **new_hough._asdict(),
        )
        if scS is not None:
            bestS = None
            bestQuality = -1.0
            for circle in scS[0]:
                if hough.minRadius <= float(circle[2]) <= hough.maxRadius:
                    quality = float(evaluate_circle_quality(processed, circle))
                    if quality > bestQuality:
                        bestQuality = quality
                        bestS = circle
            if bestS is not None:
                best_circle = bestS
                best_score = bestQuality

    if not best_circle:
        raise Exception("No circle detected")
    return best_circle, processed, best_score
